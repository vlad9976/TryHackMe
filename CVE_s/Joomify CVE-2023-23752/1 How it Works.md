The vulnerability occurs due to improper access checks against a particular GET request variable. Joomla CMS allows administrators/visitors to interact with the platform through three main entry points:

- **Admin panel**: Used for managing the website through the `/administrator` endpoint (only administrators can access the panel through a valid username and password)
- **Root directory**: The root `index.php` file renders the overall website (primarily renders content for the visitors)
- **API folder**: This folder is mainly designed for the developers to access the website content/database and, by default, disabled for general public access

The vulnerability **CVE 2023-23572** takes advantage of the API-based endpoints. It enables users to access the endpoint without authentication by manipulating the GET variable `public` value from **false** to **true**. For example, if there is an API call to `http://10.10.243.165/api/index.php/v1/contacts`. The API calls are not usually enabled for the general public; however, if the attacker sets the `public` variable value, he can bypass the code access checks and get a valid API response.  

Detail Technical Explanation

To understand how the vulnerability works, let's have a source code review to understand the control flow through different pages. We will use a vulnerable version of Joomla that can be downloaded directly from this [link](https://downloads.joomla.org/cms/joomla4/4-1-0). You can find a similar folder structure once you extract it on the desktop.  

![folder structure after installation](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/4a1381760a4202d66d65ee6a62173689.png)  

In the `api` folder, there is an `index.php` file responsible for handling all the API-based calls. The index.php further calls the app.php located in the `includes` folder.

\api\index.php

```shell-session
/**
 * Constant that is checked in included files to prevent direct access.
 * define() is used rather than "const" to not error for PHP 5.2 and lower
 */
define('_JEXEC', 1);

// Run the application - All executable code should be triggered through this file
require_once dirname(__FILE__) . '/includes/app.php';             
```

Inside the `app.php`, the `$app` variable is the most important one, storing all the HTTP request parameters and other information.

\api\includes\app.php

```shell-session
// Instantiate the application.
$app = $container->get(\Joomla\CMS\Application\ApiApplication::class);

// Set the application as global app
\Joomla\CMS\Factory::$application = $app;

// Execute the application.
$app->execute();
```

Once the `$app->execute()` function is executed, it calls the `execute()` function in the CMSApplication.php file and performs all the quick checks on system variables, sets up logging, and further calls the `doExecute()` function in `ApiApplication.php`.

\libraries\src\Application\CMSApplication.php

```shell-session
	public function execute()
	{
		try
		{
			$this->sanityCheckSystemVariables();
			$this->setupLogging();
			$this->createExtensionNamespaceMap();

			// Perform application routines.
			$this->doExecute();
```

The `doExecute()`  function is important and contains calls to three simple functions for initializing the app, setting up the routes, and rendering the application. Inside the `doExecute()` function, we have a call to `$this->route()` function, which sets all the routing parameters, fills the input variable, etc.

\libraries\src\Application\ApiApplication.php

```shell-session
		protected function doExecute()
	{
		// Initialise the application
		$this->initialiseApp();

		// Mark afterInitialise in the profiler.
		JDEBUG ? $this->profiler->mark('afterInitialise') : null;

		// Route the application
		$this->route();
```

Within the route function, there is a call to `parseApiRoute()` function of `ApiRouter.php` that parses the requested API request and returns an array. Here, we can see that the `vars` variable can be overwritten through any **user-supplied input**.

\libraries\src\Application\ApiApplication.php

```shell-session

					foreach ($route->getRouteVariables() as $i => $var)
					{
						$vars[$var] = $matches[$i + 1];
					}

					$controller = preg_split("/[.]+/", $route->getController());
					$vars       = array_merge($vars, $query);

					return [
						'controller' => $controller[0],
						'task'       => $controller[1],
						'vars'       => $vars
					];
```

The `route()` function contains the necessary code to throw an exception in case the variable's value is **false** or not set; however, it fails to ensure that the user-supplied should not change the variable's value.  

\libraries\src\Application\ApiApplication.php

```shell-session

		$this->triggerEvent('onAfterApiRoute', array($this));

		if (!isset($route['vars']['public']) || $route['vars']['public'] === false)
		{
			if (!$this->login(array('username' => ''), array('silent' => true, 'action' => 'core.login.api')))
			{
				throw new AuthenticationFailed;
			}
		}
	}
```

Moving forward, we will see how to exploit the vulnerability from an attacker's perspective.